#!/usr/bin/python3.1
import sys
import logging

from dvdvideo.media import MediaUdf
from dvdvideo.volume import MalformedVolumePartError


class Part(object):
    def __lt__(self, other):
        if isinstance(other, Part):
            if self.begin < other.begin: return True
            return self.end < other.end
        return NotImplemented

    def __repr__(self):
        return '<%s object: begin: %d; end: %d>' % (self.__class__.__name__,
                self.begin,
                self.end,
                )

    def _dump_iter(self, media):
        length = self.end - self.begin
        cur = 0
        while cur < length:
            count = min(512, length - cur)
            r = self._dump_read(media, cur, count)
            if not len(r):
                logging.debug('got eof')
                return
            cur += len(r) // 2048
            yield r

    def _dump_read(self, media, cur, count):
        try:
            return media.read(count)
        except IOError:
            logging.debug('Read error at %d', self.begin + cur)
            self._dump_seek(cur + count)
            return bytes(count * 2048)

    def _dump_seek(self, media, count, **kw):
        media.seek(self.begin + count, **kw)

    def dump(self, media):
        self._dump_seek(media, 0)
        return self._dump_iter(media)


class PartFile(Part):
    def __init__(self, file):
        if isinstance(file, (list, tuple)):
            self.begin = file[0].location
            file = file[-1]
        else:
            self.begin = file.location
        self.end = file.location + file.length


class PartVmgCopy(object):
    def _dump_iter(self, media):
        r = self._dump_read(media, 0, 1)
        r[35] = 0
        yield r

        length = self.end - self.begin
        cur = 1
        while cur < length:
            count = min(512, length - cur)
            r = self._dump_read(media, cur, count)
            if not len(r):
                logging.debug('got eof')
                return
            cur += len(r) // 2048
            yield r


class PartIfo(PartFile):
    def check(self, other):
        if isinstance(other, PartIfo):
            if self.begin >= other.begin and self.end <= other.end:
                logging.debug('Overlap between %r and %r, removing', self, other)
                return True
        else:
            if (self.begin <= other.begin and other.begin < self.end or
                self.begin < other.end and other.end <= self.end):
                raise RuntimeError('Overlap between %r and %r' % (self, other))


class PartIfoVmg(PartVmgCopy, PartIfo):
    pass


class PartIfoVts(PartIfo):
    pass


class PartBup(PartFile):
    def check(self, other):
        if isinstance(other, PartIfo):
            if (self.begin <= other.begin and other.begin < self.end or
                self.begin < other.end and other.end <= self.end):
                raise RuntimeError('Overlap between %r and %r' % (self, other))
        elif isinstance(other, PartBup):
            if self.begin >= other.begin and self.end <= other.end:
                logging.debug('Overlap between %r and %r, removing', self, other)
                return True
        elif isinstance(other, PartVob):
            if self.begin <= other.begin and other.begin < self.end:
                raise RuntimeError('Overlap between %r and %r' % (self, other))


class PartBupVmg(PartVmgCopy, PartBup):
    pass


class PartBupVts(PartBup):
    pass


class PartVob(PartFile):
    def check(self, other):
        if isinstance(other, PartIfo):
            if (self.begin <= other.begin and other.begin < self.end or
                self.begin < other.end and other.end <= self.end):
                raise RuntimeError('Overlap between %r and %r' % (self, other))
        elif isinstance(other, PartBup):
            if self.begin <= other.begin and other.begin < self.end:
                logging.debug('Overlap between %r and %r, adjusting', self, other)
                self.end = other.begin
        elif isinstance(other, PartVob):
            if self.begin == other.begin:
                if self.end <= other.end:
                    logging.debug('Overlap between %r and %r, removing', self, other)
                    return True
            elif (self.begin <= other.begin and other.begin < self.end or
                  self.begin < other.end and other.end <= self.end):
                raise RuntimeError('Overlap between %r and %r' % (self, other))

    def _dump_read(self, media, cur, count):
        try:
            return media.read(count, encrypted=True)
        except IOError:
            logging.debug('Read error at %d', self.begin + cur)
            self._dump_seek(media, cur + count)
            return bytes(count * 2048)

    def dump(self, media):
        self._dump_seek(media, 0, start_encrypted=True)
        return self._dump_iter(media)


class PartMeta(Part):
    def __init__(self, begin, end):
        self.begin, self.end = begin, end


def main(input, output):
    media = MediaUdf(input)
    part = media.udf.volume.partitions[0]

    vmg = media.vmg()
    vts = []
    for i in range(1, vmg.ifo.header.number_titlesets + 1):
        try:
            vts.append(media.vts(i))
        except MalformedVolumePartError as e:
            logging.debug('Ignore VTS %d because of errors (%s)', i, e)
            pass

    image_length = part.location + part.length

    logging.debug('image length: %d', image_length)

    parts = [PartIfoVmg(vmg.fileset.ifo),
            PartVob(vmg.fileset.menu_vob),
            PartBupVmg(vmg.fileset.bup)]

    for i in vts:
        parts.append(PartIfoVts(i.fileset.ifo))
        if i.fileset.menu_vob:
            parts.append(PartVob(i.fileset.menu_vob))
        parts.append(PartVob(i.fileset.title_vob))
        parts.append(PartBupVts(i.fileset.bup))

    logging.debug('parts: %r', parts)

    parts_removed = []
    for i in parts:
        for j in parts:
            if i is not j and j not in parts_removed:
                if i.check(j):
                    parts_removed.append(i)

    parts = [i for i in parts if i not in parts_removed]
    parts.sort()

    logging.debug('parts: %r', parts)

    parts_complete = []
    part_end = 0
    while parts:
        cur = parts.pop(0)
        parts_complete.append(PartMeta(part_end, cur.begin))
        parts_complete.append(cur)
        part_end = cur.end
    parts_complete.append(PartMeta(part_end, image_length))

    logging.debug('overall parts: %r', parts_complete)

    image = open(output, 'wb')

    cur = 0
    for part in parts_complete:
        logging.debug('part: %r', part)

        for r in part.dump(media):
            count_real = len(r) // 2048
            if cur // 5120 < (cur + count_real) // 5120:
                logging.debug('written: %d', (cur + count_real) // 512)
            cur += count_real
            image.write(r)

        logging.debug('part end, written %d', cur)

if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG)
    main(*sys.argv[1:3])
